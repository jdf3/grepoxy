#include <stdio.h>
#include <stdlib.h>

#include "addv.h"
#include "lib/g6.h"

void add_vertex();
int _makes_ind_set_aux(unsigned int, unsigned int, unsigned int*, unsigned int*);
void _add_vertex_aux(unsigned int, unsigned int*, unsigned int,
                     unsigned int*, unsigned int);

/* input is a list of adjacency matrices generated by "showg -aq" */
int main(int argc, char *argv[])
{
  char *g6 = (char *) malloc(num_bytes + 1);

  if (argc != 2) {
    fprintf(stderr, USAGE);
    exit(1);
  }

  am_sz = 0;

  sz = atoi(argv[1]);
  if (sz == 1) {
    fprintf(stderr,
            "Illegal value for size of forbidden independent set: %d", sz);
  }

  while (getline(&g6, &num_bytes, stdin) != EOF) {
    printf("GOT: "); printf(g6);
    g6_to_am(g6);
    // printf("ORDER: %d\n", v);
    //printf("TRANSLATED: "); print_g6();
    add_vertex();
  }
  free(g6);
  free_adj_mat(am, am_sz);
  return 0;
}

void add_vertex() {
  unsigned int *e;
  unsigned int i = 1;
  unsigned int *ne;
  unsigned int j = 1;

  v++;
  e = (unsigned int *) malloc((2*v)*sizeof(unsigned int)); /* problemz */
  ne = (unsigned int *) malloc((2*v)*sizeof(unsigned int)); /* problemz */
  e[0] = v;
  ne[0] = v;

  _add_vertex_aux(0, e, i, ne, j);
  free(e), free(ne);
}

void _add_vertex_aux(unsigned int s, unsigned int *e, unsigned int i,
                     unsigned int *ne, unsigned int j) {
//  printf("1\n");
  if (s == v) print_g6();
  if (!makesp3(e, s)) {
    am[s][v] = (unsigned short) 0;
//      printf("2\n");
    am[v][s] = (unsigned short) 0;
//      printf("3\n");
    e[i] = s;
//      printf("4\n");
    e[i+1] = v;
//      printf("5\n");
    ne[j] = v;
//      printf("6\n");
    _add_vertex_aux(s+1, e, i+1, ne, j);
  }
  if (!makes_ind_set(ne, s)) {
    am[s][v] = (unsigned short) 1;
//      printf("b\n");

    am[v][s] = (unsigned short) 1;
//      printf("c\n");
    ne[j] = s;
//      printf("d\n");
    ne[j+1] = v;
//      printf("e\n");
    e[i] = v;
//      printf("f\n");
    _add_vertex_aux(s+1, e, i, ne, j+1);
  }
}

/* determine whether there is a p3 including s and some vertex in e */
int makesp3(unsigned int *e, unsigned int s) {
  unsigned int p, s2, i;

  for (i = 0; (s2 = e[i]) < v; i++) {
    for (p = 0; p < v-1; p++) {
      if (am[p][s] == 1 && am[p][s2] == 1) {
        return 1;
      }
    }
  }
  return 0;
}

/* determine whether there is a clique of size sz in ne, including s */
int makes_ind_set(unsigned int *ne, unsigned int s) {
  unsigned int *inclique;
  inclique = (unsigned int *) malloc(v*sizeof(unsigned int));

  inclique[0] = s;
  return _makes_ind_set_aux(sz, 0, ne, inclique);
}

int _makes_ind_set_aux(unsigned int left, unsigned int pos,
                       unsigned int *ne, unsigned int *inclique) {
  unsigned int nv, k, p;

  if ((nv = ne[pos]) >= v - 1) return 0;
  while ((k = inclique[p]) < v - 1) {
    if (am[nv][k] == 1) {
      return 0; /* there is an edge, so with this proposed new vertex,
                 * we can never have an independent set. */
    }
    p++;
  }

  if (left - 1 == 0) return 1; /* in this case the clique is built */
  /* if we're not done, let's build cliques */

  /* either we use our new vertex */
  inclique[p] = nv;
  if (_makes_ind_set_aux(left-1, pos+1, ne, inclique) == 1) {
    return 1;
  }

  /* ...or we don't. */
  inclique[p] = v;
  return _makes_ind_set_aux(left, pos+1, ne, inclique);
}

/* Determine if the vertices given by startp3 make a P3 in am. */
int hasp3(int v, int *startp3) {
  int i, j, k;
  int *p, *r;

  p = startp3;
  if (DEBUG) fprintf(stderr, "\n");

  for (i = *p; i < v; i = *(++p)) {
    r = p+1;
    for (j = *r; j < v; j = *(++r)) {
      for (k = 0; k < v; k++) {

        if (am[i][k] == 1 && am[j][k] == 1) {
          if (DEBUG) fprintf(stderr, "(%d, %d, %d) is a P3\n", i, j, k);
          return 1;
        }
      }
      if (DEBUG) fprintf(stderr, "(%d, %d) do not form a P3\n", i, j);
    }
  }
  return 0;
}

/* Determine if the vertices given by startkk contain an independent
 * set of size sz in am. */
int hasindset(int sz, int *startkk)
{
  int i1, i2, i3, i4, i5, i6, k;
  int *p1, *p2, *p3, *p4, *p5, *p6, *d;

  p1 = malloc(sizeof(startkk));
  p2 = malloc(sizeof(startkk));
  p3 = malloc(sizeof(startkk));
  p4 = malloc(sizeof(startkk));
  p5 = malloc(sizeof(startkk));
  p6 = malloc(sizeof(startkk));
  if (DEBUG) {
    d = malloc(sizeof(startkk));
    d = startkk;
    k = *d;
    while (k < v) {
      fprintf(stderr, "%d ", k = *(d++));
    }
    fprintf(stderr, "\n");
  }
  p1 = startkk;
  switch (sz) {
    case 4:
     for (i1 = *p1; i1 < v; i1 = *(++p1)) {
      p2 = p1 + 1;
      if (DEBUG) fprintf(stderr, "l1: (%d, %d, %d, %d)", i1, *p2, *(p2+1), *(p2+2));
      for (i2 = ((*p2 > 0) ? *p2 : v); i2 < v; i2 = *(++p2)) {
       p3 = p2 + 1;
       if (am[i1][i2] == 0) {
      for (i3 = ((*p3 > 0) ? *p3 : v); i3 < v; i3 = *(++p3)) {
       p4 = p3 + 1;
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = ((*p4 > 0) ? *p4 : v); i4 < v; i4 = *(++p4)) {
         if (am[i1][i4] == 0 && am[i2][i4] == 0 &&
           am[i3][i4] == 0) {
        if (DEBUG) fprintf(stderr, "(%d, %d, %d, %d)", i1, i2, i3, i4);
        return 1;
         }
        }
       }
      }
       }
      }
     }
     return 0;

    case 5:
     for (i1 = *p1; i1 < v; i1 = *(++p1)) {
      p2 = p1 + 1;
      if (DEBUG) fprintf(stderr, "l1: (%d, %d, %d, %d, %d)", i1, *p2, *(p2+1), *(p2+2), *(p2+3));
      for (i2 = ((*p2 > 0) ? *p2 : v); i2 < v; i2 = *(++p2)) {
       p3 = p2 + 1;
       if (am[i1][i2] == 0) {
      for (i3 = ((*p3 > 0) ? *p3 : v); i3 < v; i3 = *(++p3)) {
       p4 = p3 + 1;
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = ((*p4 > 0) ? *p4 : v); i4 < v; i4 = *(++p4)) {
         p5 = p4 + 1;
         if (am[i1][i4] == 0 && am[i2][i4] == 0 &&
           am[i3][i4] == 0) {
        for (i5 = ((*p5 > 0) ? *p5 : v); i5 < v; i5 = *(++p5)) {
         if (am[i1][i5] == 0 && am[i2][i5] == 0 &&
           am[i3][i5] == 0 && am[i4][i5] == 0) {
          return 1;
         }
        }
         }
        }
       }
      }
       }
      }
     }
     if (DEBUG) fprintf(stderr, "Graph has no ind set of size %d", sz);
     return 0;

    case 6:
     for (i1 = *p1; i1 < v; i1 = *(++p1)) {
      p2 = p1 + 1;
      if (DEBUG) fprintf(stderr, "l1: (%d, %d, %d, %d, %d, %d)", i1, *p2, *(p2+1), *(p2+2), *(p2+3), *(p2+4));
      for (i2 = ((*p2 > 0) ? *p2 : v); i2 < v; i2 = *(++p2)) {
       p3 = p2 + 1;
       if (am[i1][i2] == 0) {
      for (i3 = ((*p3 > 0) ? *p3 : v); i3 < v; i3 = *(++p3)) {
       p4 = p3 + 1;
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = ((*p4 > 0) ? *p4 : v); i4 < v; i4 = *(++p4)) {
         p5 = p4 + 1;
         if (am[i1][i4] == 0 && am[i2][i4] == 0 &&
           am[i3][i4] == 0) {
        for (i5 = ((*p5 > 0) ? *p5 : v); i5 < v; i5 = *(++p5)) {
         p6 = p5 + 1;
         if (am[i1][i5] == 0 && am[i2][i5] == 0 &&
           am[i3][i5] == 0 && am[i4][i5] == 0) {
          for (i6 = ((*p6 > 0) ? *p6 : v); i6 < v; i6 = *(++p6)) {
           if (am[i1][i6] == 0 && am[i2][i6] == 0 &&
             am[i3][i6] == 0 && am[i4][i6] == 0 &&
             am[i5][i6] == 0) {
          if (DEBUG) fprintf(stderr, "(%d, %d, %d, %d, %d, %d)", i1, i2, i3, i4, i5, i6);
          return 1;
           }
          }
         }
        }
         }
        }
       }
      }
       }
      }
     }
     return 0;
  }
  return 0;
}

/* Determine if am has a C4. */
int hasc4() {
  int i, ct;
  int p = 0;

  for (i = 0; i < v; i++) {
    ct = 0;
    for (p = i + 1; p < v; p++) {
      if (am[i][p] == 1 && am[v-1][p] == 1) {
        ct++;
        if (ct == 2) return 1;
      }
    }
  }
  return 0;
}

/* Determine if the graph given by am has an independent set of size sz. */
int hasindsetnoptr(int sz) {
  int i1, i2, i3, i4, i5, i6;

  switch (sz) {
    case 4:
     for (i1 = 0; i1 < v; i1++) {
      for (i2 = i1+1; i2 < v; i2++) {
       if (am[i1][i2] == 0) {
      for (i3 = i2+1; i3 < v; i3++) {
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = i3+1; i4 < v; i4++) {
         if (am[i1][i4] == 0 && am[i2][i4] == 0 && am[i3][i4] == 0)
        return 1;
         }
        }
       }
      }
       }
      }
     return 0;

    case 5:
     for (i1 = 0; i1 < v; i1++) {
      for (i2 = i1+1; i2 < v; i2++) {
       if (am[i1][i2] == 0) {
      for (i3 = i2+1; i3 < v; i3++) {
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = i3+1; i4 < v; i4++) {
         if (am[i1][i4] == 0 && am[i2][i4] == 0 && am[i3][i4] == 0) {
        for (i5 = i4+1; i5 < v; i5++) {
         if (am[i1][i5] == 0 && am[i2][i5] == 0 && am[i3][i5] == 0 &&
           am[i4][i5] == 0)
          return 1;
        }
         }
        }
       }
      }
       }
      }
     }
     return 0;

    case 6:
     for (i1 = 0; i1 < v; i1++) {
      for (i2 = i1+1; i2 < v; i2++) {
       if (am[i1][i2] == 0) {
      for (i3 = i2+1; i3 < v; i3++) {
       if (am[i1][i3] == 0 && am[i2][i3] == 0){
        for (i4 = i3+1; i4 < v; i4++) {
         if (am[i1][i4] == 0 && am[i2][i4] == 0 &&
           am[i3][i4] == 0) {
        for (i5 = i4+1; i5 < v; i5++) {
         if (am[i1][i5] == 0 && am[i2][i5] == 0 &&
           am[i3][i5] == 0 && am[i4][i5] == 0) {
          for (i6 = i5+1; i6 < v; i6++) {
           if (am[i1][i6] == 0 && am[i2][i6] == 0 &&
             am[i3][i6] == 0 && am[i4][i6] == 0 &&
             am[i5][i6] == 0)
          return 1;
          }
         }
        }
         }
        }
       }
      }
       }
      }
     }
     return 0;

    default:
      fprintf(stderr, "Currently, this program only detects cliques of size between %d and %d, inclusive.\n", \
          MINCLIQUE, MAXCLIQUE);
  }
  return 0;
}
